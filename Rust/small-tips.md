## 2020-09-24

Rust 当中只关心位置和值。除非与 trait object 相关，否则不会用“对象”这个术语。

Rust 的很多内建类型均标记为 `Copy` trait。标记为 `Copy` 的类型在按值传参、赋值的时候会取复制语义，可以理解成将一块内存原样复制到另一个地方，并通常绑定到不同的名字下面；否则，通常为了保证值不能出现多次或是有一些限制，在按值传参、赋值的时候会取**移动**语义。它大致可以分成两个阶段：前一阶段和 `Copy` 一致，后一阶段则是要在编译器层面 invalidate 掉被移动的变量，禁止它再被访问。那么被移动的变量对应的位置又该何去何从呢？这个问题暂时难以得出结论。

另一个问题是，对于自己创建的类型，`Copy` 和 `Drop` 不能并存。这可能是因为，标记为 `Copy` trait 的类型，和一段固定大小的空间没有什么区别。而未被标记为 `Copy` trait 的类型，由于它被限制为只能取移动语义，往往在释放的时候都不是直接扔掉那一块空间了事即可，而是要有一些相应的处理。

一个强大的[链接](https://zhuanlan.zhihu.com/p/189694498)

## 2020-09-25

上面的经典文章，提到了位置和值的概念，按照我的理解，位置就是指一块内存（无论是全局数据、堆、还是栈），而值当然指的是这块内存中保存的内容。

**位置**

一个位置可能有以下的五种状态：

1. 位置存在，但里面还没有值；
2. 位置存在，且里面也有值；
3. 位置存在，里面曾经有值，但现在被移走了；
4. 位置存在且有值，正在被共享借用（多个不可变借用）；
5. 位置存在且有值，正在被独占借用（单个可变借用）。

我们分别重新叫做未初始化、有值、deleted、&、&mut 状态吧。

状态只是位置的第一重属性，他还具有其他属性。

比如位置的类型属性，包括类型大小、内存对齐以及析构方法，还有一些标记。当一个类型被标记为 `Copy` trait 的时候，与该类型相关的位置就不存在 deleted 状态。事实上，将自定义的类型标记为 `Copy` 之后，无法再为其实现 `Drop` trait，其中的原因我昨天尝试分析了一下。

还有位置的可变性属性（w: 大概可变性放在位置这个层面而不是变量这个层面会更好一些）。当没有 mut 的时候，一个位置就不能位于状态 &mut，且离开了未初始化状态之后，里面的值不能发生变化。

位置的来源：通过定义变量、函数参数、返回值均可生成带名字的位置，变量可以视为**名字与位置的绑定**。此外，还有一些隐式的临时变量也会有对应的位置，只是我们无法显式访问罢了。

**值**

类型决定了值的内存布局。

Python 和 Java 这类语言提供值的运行时管理器，而 Rust 一切都在编译器中完成。

**观测交互**

打印一个位置的地址会引发编译器关于内存分配策略的变化。

**赋值(assignment)**

Rust 的赋值机制相比其他语言有很多不同。

假设 a,b 两个位置有着相同的类型，我们想要实现 a = b(即 a 为目标，b 为源)

在编译的时候我们需要依次检查：

1. 若 a,b 处于 & 或 &mut 状态，它们将在这一瞬间回到有值状态。这也就意味着所有关于它们的引用不能在这之后继续存在，编译期的借用检查器会帮我们检查是否产生生命周期冲突。
2. 若位置 a 处于有值或 deleted 状态，且位置 a 并不是 mut 的，报错；
3. 若位置 b 处于未初始化状态或 deleted 状态，报错。

这里我写了一段代码来验证第一条：

```rust
fn main() {
    let mut p1 = Person { v: 10, };
    let rp = &p1;
    let p2 = Person { v: 11, };
    p1 = p2;
    println!("{:?}", *rp);
}
```

会报出编译错误：

```rust
error[E0506]: cannot assign to `p1` because it is borrowed
  --> src\main.rs:15:5
   |
13 |     let rp = &p1;
   |              --- borrow of `p1` occurs here
14 |     let p2 = Person { v: 11, };
15 |     p1 = p2;
   |     ^^ assignment to borrowed `p1` occurs here
16 |     println!("after world!");
17 |     println!("{:?}", *rp);
   |                      --- borrow later used here
```

我敢说如果是 C 语言这样肯定没有问题。

这告诉我们，借用是对于**值**的借用而非对于**位置**的借用。注意下面的运行时步骤，若没有被标记为 Copy，实际上 p1 里面的值在运行时第一步已经被销毁，在值被销毁之后，之前的对于它的借用 rp 也就失效了。而我们又尝试去访问它，即在编译期发现了借用错误。

注意，即使将 `Person` 标记为 `Copy` 该问题也同样没有得到解决，不能通过编译。

但是 p2 的情况则稍有不同。若 p2 被标记为 Copy 的话，p2 位置里面的值其实不会受到影响，因此跨越它的借用不会出现问题；但反之，p2 位置里面的值需要被 invalidate，由于借用是对值进行借用，就不行了。

所以在我看来，原作的说明不太完整。已经提出评论了，期待和 dalao 交流一下。

运行时步骤：

1. 如果 a 处于有值状态，且类型不是 `Copy` 的，那么**对于 a 里面的值进行析构**，从而进入 deleted 状态；
2. 将位置 b 里面的值按位复制到位置 a 中，位置 a 进入有值状态；
3. 如果类型不是 `Copy` 的，位置 b 进入 deleted 状态。

(w: 这样看来的话，一个位置处于未初始化和 deleted 的状态虽然都不能访问，但是报出的错误却应该是不同的。)

**所有权到底是什么**

感觉一下子懂了好多东西，明天再继续来看，[here](https://zhuanlan.zhihu.com/p/201220495)。



