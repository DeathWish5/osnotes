## 2020-09-24

Rust 当中只关心位置和值。除非与 trait object 相关，否则不会用“对象”这个术语。

Rust 的很多内建类型均标记为 `Copy` trait。标记为 `Copy` 的类型在按值传参、赋值的时候会取复制语义，可以理解成将一块内存原样复制到另一个地方，并通常绑定到不同的名字下面；否则，通常为了保证值不能出现多次或是有一些限制，在按值传参、赋值的时候会取**移动**语义。它大致可以分成两个阶段：前一阶段和 `Copy` 一致，后一阶段则是要在编译器层面 invalidate 掉被移动的变量，禁止它再被访问。那么被移动的变量对应的位置又该何去何从呢？这个问题暂时难以得出结论。

另一个问题是，对于自己创建的类型，`Copy` 和 `Drop` 不能并存。这可能是因为，标记为 `Copy` trait 的类型，和一段固定大小的空间没有什么区别。而未被标记为 `Copy` trait 的类型，由于它被限制为只能取移动语义，往往在释放的时候都不是直接扔掉那一块空间了事即可，而是要有一些相应的处理。

一个强大的[链接](https://zhuanlan.zhihu.com/p/189694498)

