# RV32I/RV64I

这里主要系统的学习一下 RISC-V 的非特权级架构。

## RV32I

### 寄存器

* 32 个 32 位寄存器 `x0~x31`，另外还有一个 `pc`。

* 一般约定 `x1` 作为 `ra` 使用，`x2` 作为 `sp` 使用，`x5` 作为一个备用的 `ra` 使用，看另一本书上说可能与协程相关。

### 指令概述

* 指令格式上，主要分成四种 R/I/S/U，所有指令的长度均为 4 字节。

  ![](不同的指令类型.png)

  > 可以看出，R 类型中没有立即数，只与 *rs1,rs2,rd* 三个寄存器有关；I 类型中没有 *rs2* ，但是带一个 12 位的立即数；S 类型没有 *rd*，与 I 类型一样带一个 12 位的立即数，一般与 LOAD/STORE 指令相关；U 类型没有 *rs1,rs2*，但带有一个 20 位的立即数，常作为 32 位的高 20 位使用。
  >
  > 其中 s, d 分别指 source 和 destination，即源和目标。

  另有两种与跳转相关的指令格式 B/J，分别在 S/U 格式的基础上对于立即数的置位、含义进行修改，如下图所示：

  ![](跳转指令类型.png)

  大概列一张表格将不同的指令格式整理一下：

  | 指令格式 | 相关寄存器 | 立即数            |
  | -------- | ---------- | ----------------- |
  | R        | rs1,rs2,rd | 不存在            |
  | I        | rs1,rd     | 12 位立即数       |
  | S(B)     | rs1,rs2    | 12 位立即数       |
  | U(J)     | rd         | 20 位立即数(高位) |

* 在所有指令中 *rs1,rs2,rd* 寄存器均放在相同的位置来简化解码。

* 除了在 CSR 相关指令中用到的 5 位立即数之外，所有指令的立即数均为符号扩展。

### 整数计算指令

两个寄存器 *rs1,rs2* 或者一个寄存器 *rs1* 与一个立即数 *imm* 进行某种运算，并将结果保存在 *rd* 寄存器中，计算不会产生任何异常。之所以不通过异常来处理溢出等问题是因为通过分支指令就能很方便的处理

* 寄存器-立即数指令

  操作类型 ADDI/SLTI[U]/ANDI/ORI/XORI 记为 op，则指令格式为 *op rd, rs1, imm*，这里 12 位立即数均被用上，属于 I 类指令。需要注意的是不满足交换性的 SLTI[U] 是将 *rs1 < signedext(imm)* 写入 *rd*；

  操作类型 SLLI/SRLI/SRAI 记为 op，则指令格式为 *op rd, rs1, imm*，注意这里 *imm* 只有较低的 5 位有效，属于 I 类指令。

  另有两条指令属于 U 类指令，指令格式为 *op rd, imm*，这里的 *imm* 为 20 位，其中：

  * LUI(load upper immediate) 的语义为 rd := imm << 12，常用来构建一个完整的 32 位整数的高 20 位；
  * AUIPC(add upper immediate pc) 的语义为 rd := pc + (imm << 12)，常用来构造相对于 pc 的长地址跳转(事实上，可以在整个 32 位地址空间内随便跳)

  值得一提的是 NOP 指令实质上是 *ADDI x0, x0, 0*。

* 寄存器-寄存器指令

  操作类型 ADD/SLT/SLTU/AND/OR/XOR/SLL/SRL/SUB/SRA 记为 op，则指令格式为 *op rd, rs1, rs2*，注意不满足交换性的是 SLT[U]，它比较的是 *rs1 < rs2* 的结果；以及 SUB，它将 *rs1 - rs2* 的结果写入寄存器 *rd*。这些指令明显都是 R 类指令。

### 控制指令

#### 无条件跳转（Unconditional Jumps）

* 直接跳转指令 JAL（**J**ump **A**nd **L**ink）

  *JAL rd, imm*是一条从 U 型指令修改得到的 J 型指令，因此相关寄存器只有一个 *rd*，还有一个长达 20 位的立即数 *imm*。

  其语义为 *rd := PC + 4; PC := PC + imm*，从调用规范的角度 *rd* 一般为 `x1/x5`，从而可以通过 RET 指令返回到下一条指令继续执行。

  由于 *imm* 只有 20 位，因此直接使用 JAL 只能使 PC 跳转到相对当前位置 $\pm1\text{MiB}$ 的区间内。

  相关伪指令： J

* 间接跳转指令 JALR（**J**ump **A**nd **L**ink **R**egister）

  *JALR rd, rs1, imm* 则是一条 I 型指令，它带有一个 12 位的立即数 *imm*。

  它可以跳转到 *rs1* 内保存的地址附近的一个位置，其实际语义为 *rd := PC + 4, PC := rs1 + imm*。

  AUIPC + JALR 是一个常见的 Combo，可以相对于 PC 当前值跳转到整个 32 位地址空间。

* 有关 `x1/x5` 以及 RAS（**R**eturn-**A**ddress **S**tack）后面还有更加详细的说明，有兴趣的读者可以参考源文档

#### 条件跳转（Conditional Branches）

这类指令都是 B 型指令，从 S 型指令修改得到，因此相关寄存器只有 *rs1, rs2*，且有一个长度为 12 位的立即数。它们的功能是比较两个寄存器，并根据比较结果决定是否跳转到 *PC + imm*，也就是相对当前位置一个 $\pm4\text{KiB}$ 的地方。

指令格式为 *op rs1, rs2, imm*，其中 *op* 代表不同的比较方式，目前存在的比较方式有：BEQ/BNE/BLT[U]/BGE[U]，对于不满足交换性的比较方式，仍是 *rs1* 在前 *rs2* 在后。

这种跳转指令的跳转范围比较受限，如果需要跳转到更远的地方，需要在条件跳转之后再接一次跳转范围较大的无条件跳转。

### LOAD/STORE 指令

* LOAD 类指令从内存将数据读入寄存器，它是一条 I 型指令，即涉及寄存器 *rs1, rd* ，另有一个 12 位的立即数 *imm*，因此，指令格式应为 *LOAD rd, rs1, imm*。它的语义是：*rd := \*(rs1 + imm)*。显然，为了读取任意一个 32 位地址处的值，我们需要将 LUI 与 LOAD 组合起来进行使用。

  在实际使用中，我们根据所要读入数据的大小选择不同的具体指令：

  * LW 指令从内存将一个 32 位的值读入寄存器；
  * LH[U] 指令从内存读一个 16 位的值，并将其符号扩展[零扩展]后保存到寄存器中；
  * LB[U] 指令同 LH[U] 指令，只不过一开始从内存中读的是一个 8 位的值。

  当数据大小超过 1 字节之后，我们就要特别当心端序的影响。比如，同样是一个 32 位的值，$\mathtt{0x1234\_5678}$，同样存储在内存上的地址区间 $[\mathtt{0x1000,0x1004})$ 上：若是大端序存储的话，高字节保存在内存的低地址，那么这个地址区间从低到高分别保存 $\mathtt{0x12,0x34,0x56,0x78}$；若是小段序存储的话，低字节保存在内存的低地址，那么这个地址区间从低到高依次保存 $\mathtt{0x78,0x56,0x34,0x12}$。当我们从内存中读出一个 32 位的值，想知道当时我们写进去的 32 位的值到底是什么的话，就得知道是大端序还是小端序，才能进行恰当的格式转换拿到正确的数据。而如果我们以 1 字节为单位进行读写，那么显然就不用考虑端序的影响。

  究竟是大端序还是小端序，是由下层的 EEI 来决定的。

* STORE 类指令将数据从寄存器写入内存，它是一条 S 型指令，即涉及寄存器 *rs1, rs2*，另有一个 12 位的立即数 *imm*，因此，指令格式应为 *STORE rs1, rs2, imm*。其中 *rs1* 代表 base，*rs2* 中保存要写入的数据，故实际语义应为 *\*(rs1 + imm) := rs2*。

  STORE 类指令受数据大小的影响较小，SW/SH/SB 分别表示将 *rs2* 中所存储值的较低 32/16/8 位写入内存中 *rs1+imm* 开头，长度分别为 4/2/1 字节的地址区间。当然，写的时候要注意端序。

* 后面还有提到 EEI 如何处理数据不对齐读写，但我们这里略过不谈。

### FENCE 类指令

* 暂且略过。

### ECALL/EBREAK

* 需要结合 trap 处理，这里略过。

### 伪指令一览

更多可以参见[这里](https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)的第 20 章。

| 伪指令  | 语义                               | 实现方式      |
| ------- | ---------------------------------- | ------------- |
| *J imm* | 直接跳转到 *imm* ，并可以 RET 返回 | *JAL x0, imm* |

