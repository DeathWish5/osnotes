Rust的内存一致性模型源自于C++的内存一致性模型，但是似乎也有一些不同，是因为C++20更新了？

[这里](https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering)给出了acquire-release模型的更精确的描述：A线程上的ordering::Release的Store和B线程上的ordering::Acquire的Load均针对同一个原子变量（当然还需要一些其他的前提条件），则B在Load之后需要能够看到A在Store之前的所有内存操作（包括非原子访问和ordering::Relaxed的原子操作）。最简单的做法可能就是将A所在的核的局部缓存上的内容写回到内存。

我之前一直误认为只需要内存一致性模型仅关注同步原子变量自身。但实际上在最经典的锁模型下，我们要保护的主要是**共享数据结构**，而原子变量仅仅是一个标志而已。因此在一个线程拿到锁之后，它必须看到最新的共享数据结构，而不能让那些修改仍留在局部缓存中。

这也就印证了：内存一致性（Consistency）模型是关注内存中的多个位置的值能否被其他线程看到，而缓存一致性（Coherence）协议则只是关注单个原子变量。

之后有时间的话再来看一下其他内容。



``memory_order``能够对非原子内存访问跟随原子指令进行排序。在多核系统上如果没有任何限制，对多个变量同时读写将会造成：一个线程观测到的值的变化顺序与另一个线程修改它们的顺序不一致。即使是在单核上，由于编译器可能随意调换访存顺序，类似的现象也有可能出现。

默认情况下所有的原子操作均提供*顺序一致性*，但是这会大幅降低性能。大多数情况下，更弱的一致性就够用了。

* Relaxed仅保证操作自身的原子性；
* Consume和Release顺序组成Consume-Release模型，就像Acquire-Release模型一样。我们暂时忽略它。