# K210 移植与多核支持总结报告

## 小问题

在撰写本报告的时候，我又想到了某些实现有一点小问题，先记录下来：

1. CPU 核数、频率以及内存大小都可以通过设备树查询，目前都是硬编码；
2. K210 串口中断处理利用 mstatus.mprv 可以做到更好；
3. 将 k210-sdk-stuff/k210-hal/k210-pac 移出项目，不然代码行数太夸张了；
4. 如何处理 icache 刷新；

## 实验结果

目前在代码可以在[这里](https://github.com/wyfcyx/rCore-Tutorial/tree/multicore)找到，其中的 [README.md](https://github.com/wyfcyx/rCore-Tutorial/tree/multicore#quick-run) 提到了如何运行 tutorial。Qemu 平台与原先保持不变，K210 平台则需要进行如下步骤：

1. 准备好 microSD 卡用于放置文件系统（可以在[这里](https://item.jd.com/1875992.html)购买，质量不过关的 SD 卡会引起很多不必要的麻烦）

   将 microSD 卡放入读卡器并插入 PC，随后（目前只支持 Ubuntu 或虚拟机）

   ```sh
   cd user && make sdcard
   ```

2. 将 microSD 卡插入 K210 开发板

3. 切换到主目录，并 `make run BOARD=k210`。

在启动之后会进入用户终端，键入用户程序的名称即可运行该程序。目前支持三个用户程序：

1. hello_world
2. notebook[特别地，通过 Ctrl + C 可以退出]
3. fantastic_text

在每个用户程序运行结束后，会给出其主线程的运行统计信息，即其在每个核的用户态和内核态各运行了多长时间。单位是 CPU 的时钟周期。如：

```rust
thread 4 exit with code 0
on Core #0, user time = 11915, kernel time = 13772
on Core #1, user time = 10892, kernel time = 29879
total user = 22807, kernel = 43651, sum = 66458
Process 3 exited
```

若要退出整个 OS，Qemu 平台可以通过 Ctrl A + X，K210 平台则可以通过 Ctrl + ]。

目前的多核仅支持到原 master 分支，即还不支持 lab3+ 的虚拟存储。但是单核情况下，已经能在 K210 上跑 lab3+ 了，参见[这里](https://github.com/rcore-os/rCore-Tutorial/tree/lab-3+)。

下面，我们分别介绍一下相关的改动：

## 将 OpenSBI 换成 RustSBI

[RustSBI](https://github.com/luojia65/rustsbi) 是在 2020 年 OS 夏令营活动中完善的一个项目。它基于已有的 Rust 嵌入式生态用 Rust 语言重写 [OpenSBI](https://github.com/riscv/opensbi)，目前我们所用到的 OpenSBI 中的功能 RustSBI 都已经实现了，还有一些相比 OpenSBI 更为强大的功能（如软中断、向后兼容 S 特权级软件等），且更加轻量级。至少在 Qemu 和 K210 平台上基于 RustSBI 跑我们的 Tutorial 已经不成问题，于是我们全面将 Tutorial 中的 OpenSBI 换成 RustSBI。

我们将预编译好的镜像 `rustsbi-qemu.bin` 和 `rustsbi-k210.bin` 保存在项目的 `bootloader` 目录下，在启动时使用。

## 多平台架构

为了能够同时支持 Qemu/K210 两个平台，新增 `board` 目录保存两个平台硬件上不同的地方：

```
board/
	- k210/
		- mod.rs
		- config.rs
		- entry.asm
		- interrupt.rs
		- linker.ld
	- qemu/
		- mod.rs
		- config.rs
		- entry.asm
		- interrupt.rs
		- linker.ld
	- mod.rs
```

下面我们分别来看看它们的用途：

`config.rs` 中的内容（以 K210 平台）为例：

```rust
// 硬编码的可用物理地址结尾
pub const BOARD_MEMORY_END_ADDRESS: usize = 0x8060_0000;
// 适应当前平台的内核堆大小
pub const BOARD_KERNEL_HEAP_SIZE: usize = 0x20_0000;
// 适应当前平台的运行栈大小
pub const BOARD_STACK_SIZE: usize = 0x8000;
// 适应当前平台的内核栈大小
pub const BOARD_KERNEL_STACK_SIZE: usize = 0x8000;
// 所有需要用到的外设 MMIO 地址区间
// 值得一提的是，我们会在 MemorySet::new_kernel 的时候插入相应的映射
pub const MMIO_INTERVALS: &[(usize, usize)] = &[
    (0x0200_0000, 0x1000), /* CLINT     */
    (0x0C00_0000, 0x1000), /* PLIC      */
    ...
    (0x5400_0000, 0x1000), /* SPI2      */
];
// CPU 实现的 RISC-V 规范版本
// 目前唯一用到的地方是 1.9 和 1.10 一个显著的差异
// 即 sstatus.sum 和 sstatus.pum 意义完全相反
// 需要根据版本来判断是否设置这一位
pub const RISCV_SPEC_MAJOR: usize = 1;
pub const RISCV_SPEC_MINOR: usize = 9;
pub const RISCV_SPEC_PATCH: usize = 1;
// 核心数，用于多核
pub const CPU_NUM: usize = 2;
// CPU 频率，目前直接硬编码
pub const CPU_FREQUENCY: usize = 390000000;
```

`entry.asm` 和 `linker.ld` 则会在构建的时候将当前构建平台的版本复制到 `os/src/entry.asm` 和 `os/src/linker.ld` 用于实际的构建。`entry.asm` 中只有为每个核设置的启动栈大小不同，以及启动栈的数量（等于核数）不同；而 `linker.ld` 中则是内核的起始虚拟地址 `BASE_ADDRESS` 不同。

`interrupt.rs` 分别保存了两个平台上不同的中断服务例程。在 K210 平台上，由于该平台奇怪的属性，`supervisor_external` 的功能被移交给 `supervisor_soft`。除此之外二者没有不同。

`mod.rs` 实现了两份 `device_init` 函数，因为两个平台在这一阶段要做的事情并不相同。

`board/mod.rs` 则会将这些设置根据不同的目标平台 export 出来给 Tutorial 的其他模块使用。

```rust
#[cfg(feature = "board_k210")]
pub use k210::{config, device_init, interrupt};
#[cfg(feature = "board_qemu")]
pub use qemu::{config, device_init, interrupt};
```

比如，当目标平台是 K210 的时候，`crate::board::config::*` 就会是 K210 的配置，反之则会是 Qemu 的配置。

要让用于区分的两个 feature `board_k210, board_qemu` 发挥作用，首先我们要在 `Cargo.toml` 中进行声明：

```toml
[features]
board_qemu = []
board_k210 = []
```

接下来 `Makefile` 中也要加以改动：

```makefile
# 编译 kernel 的时候复制 linker.ld 和 entry.asm 并加上相应 feature
kernel:
	@cp src/board/$(BOARD)/linker.ld src/linker.ld
	@cp src/board/$(BOARD)/entry.asm src/entry.asm
	@cargo build --features "board_$(BOARD)"
	
run: build run-inner
run-inner: build
# 判断当前的目标平台
ifeq ($(BOARD),qemu)
	@qemu-system-riscv64 \
    		-machine virt \
    		-nographic \
    		# 这里换成 RustSBI
    		-bios $(BOOTLOADER) \
    		-device loader,file=$(BIN_FILE),addr=0x80200000 \
    		-drive file=$(IMG_FILE),format=qcow2,id=sfs \
    		-device virtio-blk-device,drive=sfs \
    		# 开启多核
			-smp 4
else
	# K210 一键运行，后面再说
endif
```

由此，即可 `make run` 跑 Qemu，`make run BOARD=k210` 跑 K210。

## K210 移植

感谢 @freheit889 的工作，让很多坑得以提前被解决！

下述的移植代码，虽然是为了能正常在 K210 上跑起来，但是在 Qemu 上也是用的同样的代码。

本节的内容截止到能单核在 K210 上跑 lab1~lab6 和 lab3+ 为止，多核还会有一些变化。

### 启动流程

还是从 `os/Makefile` 的那个地方来看：

```makefile
SBI			?= rustsbi
BOOTLOADER	:= ../bootloader/$(SBI)-$(BOARD).bin
# 目前仅支持 Ubuntu，默认为 /dev/ttyUSB0
K210-SERIALPORT	= /dev/ttyUSB0
K210-BURNER		= ../tools/kflash.py	

run-inner: build
ifeq ($(BOARD),qemu)
	# 运行 Qemu
else
	# 将 RustSBI 镜像与 kernel 拼接在一起
	@cp $(BOOTLOADER) $(BOOTLOADER).copy
	@dd if=$(BIN_FILE) of=$(BOOTLOADER).copy bs=128K seek=1
	@mv $(BOOTLOADER).copy $(BIN_FILE)
	# 给 k210 的串口设备必要的权限
	@sudo chmod 777 $(K210-SERIALPORT)
	# 通过工具 kflash.py 将内核镜像烧写到 k210 的 flash 内，并启动串口终端
	# 注意，此工具依赖于 pyserial
	python3 $(K210-BURNER) -p $(K210-SERIALPORT) -b 1500000 -t $(BIN_FILE)
endif
```

烧写的速度大概只有 30~40KiB 每秒，因此我们将 K210 平台上的 `BASE_ADDRESS` 调整为 $\mathtt{0xFFFF\_FFFF\_8002\_0000}$ 正是为了缩小最后的内核镜像大小并提高烧写速度。

### 清空 .bss section

在裸机平台上，清空 .bss 段是一项很重要的工作，我们要在访问任何零初始化的全局变量之前完成它。

```rust
// memory/mod.rs
fn clear_bss() {
    extern "C" {
        fn sbss_clear();
        fn ebss_clear();
    }
    let bss_start = sbss_clear as usize;
    let bss_end = ebss_clear as usize;
    let bss_aligned = bss_end - bss_end % 8;
    // clear bss section
    (bss_start..bss_end).step_by(8).for_each(|p| {
        unsafe { (p as *mut u64).write_volatile(0) }
    });
    if bss_aligned < bss_end {
        (bss_aligned..bss_end).step_by(1).for_each(|p| {
            unsafe { (p as *mut u8).write_volatile(0) }
        });
    }
}
```

我们也需要给出要初始化的部分的符号定义：

```
# linker.ld
bss_start = .;
    .bss : {
	    *(.bss.stack)
        sbss_clear = .;
        *(.sbss .bss .bss.*)
        ebss_clear = .;
    }
```

注意我们不能将整个 .bss 段清空，那样会错误的将启动栈清空。

### MMU 相关

初始内核映射中新增了以下大页：

```diff
// entry.asm
boot_page_table:
+    .8byte (0x00000 << 10) | 0xcf
+    .8byte (0x40000 << 10) | 0xcf
     .8byte (0x80000 << 10) | 0xcf
     .zero 505 * 8
     .8byte (0x00000 << 10) | 0xcf
+    .8byte (0x40000 << 10) | 0xcf
     .8byte (0x80000 << 10) | 0xcf
     .8byte 0
```

这是为了无论用虚拟地址还是物理地址都能访问到所有外设的设备寄存器（K210 上某些外设的 MMIO 地址在 $\mathtt{0x4000\_0000}$ 之后）。



确定了 K210 平台所有能用到的设备 MMIO 区间：

```rust
// board/k210/config.rs
pub const MMIO_INTERVALS: &[(usize, usize)] = &[
    (0x0200_0000, 0x1000), /* CLINT     */
    (0x0C00_0000, 0x1000), /* PLIC      */
    ...
    (0x5400_0000, 0x1000), /* SPI2      */
];
```

并在创建进程地址空间的时候映射过去：

```rust
// memory/mapping/memory_set.rs MemorySet::new_kernel
for mmio_pair in MMIO_INTERVALS.iter() {
    segments.push(
        Segment {
            map_type: MapType::Device,
            range: Range::from(VirtualAddress(mmio_pair.0)..VirtualAddress(mmio_pair.0 + mmio_pair.1)),
            flags: Flags::READABLE | Flags::WRITABLE,
        }
    );
}
```

这里的 `MapType::Device` 是一种新增的映射类型，可看作是一种偏移量为 0 的 `MapType::Linear`。提供这种映射的原因是 K210 的设备驱动库直接访问物理地址而非虚拟地址。

```rust
// memory/mapping/mapping.rs Mapping::map
MapType::Device => {
    for vpn in segment.page_range().iter() {
        self.map_one(vpn, Some(PhysicalPageNumber(vpn.0)), segment.flags | Flags::VALID)?;
    }
}
```



根据 RISC-V 规范版本决定要不要设置 status.sum 位。

```rust
// memory/mod.rs
if RISCV_SPEC_MINOR >= 10 {
    println!("riscv spec version >= 1.10!");
    unsafe { riscv::register::sstatus::set_sum() };
}
```



由于 K210 上的 1.9.1 版本不区分 LoadPageFault 和 LoadFault 两个异常，而是只有一种 LoadFault 异常（Store/Instruction 同理）。我们需要在 `handle_interrupt` 中加入相应分支处理缺页异常：

```rust
// interrupt/handler.rs
        | Trap::Exception(Exception::LoadFault)
        | Trap::Exception(Exception::StoreFault)
        | Trap::Exception(Exception::InstructionFault) => page_fault(context, scause, stval),
```



### 刷新 icache

在 `main.rs` 即将通过 `__restore` 切换到第一个线程之前刷新了一下 icache：

```rust
llvm_asm!("fence.i" :::: "volatile");
```

理论上来说在内存中写入可能会被取指的部分之后确实应该刷新一下 icache，而且曾经确实遇到过由于没有刷新 icache 导致取到错误指令的情况。但是现在好像把它删除掉也没问题。麻烦的事情是，如果想自圆其说，在每个应该刷新的地方都刷新一下是相当复杂的。所以这个家伙到底如何处理还需要讨论一下。

### 串口中断

之前提到过，K210 的 S 特权级软中断和外部中断处理正好调换了一下。这是由于 K210 的硬件缺陷，S 特权级外部中断不存在。因此我们只能在 [RustSBI 的 M 特权级外部中断](https://github.com/luojia65/rustsbi/blob/master/platform/k210/src/main.rs#L381)中进行处理并转发给 S 特权级软中断。这使得 K210 的中断处理看起来非常奇怪。

```rust
// board/k210/interrupt.rs
// just return
pub fn supervisor_external(context: &mut Context) -> *mut Context {
    context
}
pub fn supervisor_soft(context: &mut Context) -> *mut Context {
    // RustSBI: read character from serial and save it into stval CSR
    let mut c = stval::read();
    // just like supervisor_external on Qemu platform
    if c <= 255 {
        if c == '\r' as usize {
            c = '\n' as usize;
        }
        STDIN.push(c as u8);
    }
    // clear SSIP
    unsafe {
        let mut _sip: usize = 0;
        llvm_asm!("csrci sip, 1 << 1" : "=r"(_sip) ::: "volatile");
    }
    context
}
```

为了和 Qemu 一样只在 hart0 上进行串口中断的接收与处理，我们要在初始化的时候做如下工作：

```rust
// board/k210/mod.rs
pub fn device_init(_: PhysicalAddress) {
    // after RustSBI, txen = rxen = 1, rxie = 1, rxcnt = 0
    // start UART interrupt configuration
    // disable external interrupt on hart1 by setting threshold
    let hart0_m_threshold: *mut u32 = 0x0c20_0000 as *mut u32;
    let hart1_m_threshold: *mut u32 = 0x0c20_2000 as *mut u32;
    unsafe {
        hart0_m_threshold.write_volatile(0u32);
        hart1_m_threshold.write_volatile(1u32);
    }
    // now using UARTHS whose IRQID = 33
    // assure that its priority equals 1
    let uarths_irq_priority: *mut u32 = (0x0c00_0000 + 33 * 4) as *mut u32;
    assert_eq!(unsafe{ uarths_irq_priority.read_volatile() }, 1);
    // open interrupt enable register on PLIC
    let hart0_m_int_enable_hi: *mut u32 = 0x0c00_2004 as *mut u32;
    unsafe {
        hart0_m_int_enable_hi.write_volatile(1 << 0x1);
    }
    // now, we can receive UARTHS interrupt on hart0!
	// 接下来要对 sd 卡进行初始化，会修改某些 PLL 的频率进而串口的频率会受到影响
    // 我们需要等待一段时间确保串口缓冲内的字符全部输出，不然会出现乱码
    crate::drivers::soc::sleep::usleep(1000000);
} 
```

### SDCard 驱动

主要来自以下项目：[k210-sdk-stuff](https://github.com/laanwj/k210-sdk-stuff)。新增的 `drivers/soc` 目录以及 `drivers/block/sdcard.rs` 都修改自于该项目。此外，k210-sdk-stuff 还依赖于 [k210-pac](https://github.com/riscv-rust/k210-pac) 和 [k210-hal](https://github.com/riscv-rust/k210-hal) 两个库。由于它们都需要修改，所以目前是把这两个库直接丢进 Tutorial 项目里面了。可以在项目根目录的 `tools` 目录下找到它们。

不谈硬件的细节，`sdcard.rs` 提供了一个 `Sd_card` 类并实现了 `BlockDevice` 接口。因而在 `fs/mod.rs` 中，我们这样来初始化文件系统：

```rust
#[cfg(feature = "board_k210")]
lazy_static! {
    /// 根文件系统的根目录的 INode
    pub static ref ROOT_INODE: Arc<dyn INode> = {
        let device = Arc::new(Sd_card::new());
        let sfs = SimpleFileSystem::open(device).expect("failed to open SFS");
        sfs.root_inode()
    };
}
```

其他部分和 Qemu 均保持一致。

### 用户态终端

首先要新增一个系统调用 `sys_exec` 表示启动一个新进程并**永久阻塞当前进程**（这个后面还会修改）

```rust
// kernel/process.rs
pub (super) fn sys_exec(path:*const u8,context:Context)->SyscallResult{

    let name=unsafe{from_cstr(path)};
    let app = ROOT_INODE.find(name);
    match app{
        Ok(inode)=>{
            let data = inode.readall().unwrap();
            let elf = ElfFile::new(data.as_slice()).unwrap();
            let process = Process::from_elf(&elf, true).unwrap();
            let thread=Thread::new(process, elf.header.pt2.entry_point() as usize, None).unwrap();
            PROCESSOR.lock().add_thread(thread);
            PROCESSOR.lock().sleep_current_thread();
            PROCESSOR.lock().park_current_thread(&context);
            PROCESSOR.lock().prepare_next_thread();
        },
        Err(_)=>{
            println!("");
            println!("command not found");
        }
    }
    SyscallResult::Proceed(0)
}
pub unsafe fn from_cstr(s:*const u8)->&'static str{
    use core::{slice,str};
    let len=(0usize..).find(|&i| *s.add(i)==0).unwrap();
    str::from_utf8(slice::from_raw_parts(s,len)).unwrap()
} 
```

其他地方也要对应修改：

```rust
// kernel/syscall.rs
pub const SYS_EXEC: usize = 221;

SYS_EXEC => sys_exec(args[0] as *const u8, *context),
```

用户态的改动则比较简单，可自行去了解。

值得一提的是，在 K210 平台上内存资源宝贵，因此在构建用户程序的时候使用 release 模式并扔掉调试相关的段：

```makefile
build: dependency
ifeq ($(MODE),release)
	@cargo build --release
else
	@cargo build
endif
	$(foreach bin_file,$(BIN_FILES),riscv64-unknown-elf-objcopy --strip-debug $(bin_file) $(bin_file);)
```

## 多核支持

