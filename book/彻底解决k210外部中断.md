# 彻底解决 K210 外部中断

之前的话只能说是用非常不优雅且不具拓展性的方式勉强让串口能够工作，剩下的外部中断可能就完全不支持了。前段时间在洛佳的提醒之下想到可以通过设置 mstatus.mprv 来在 M 特权级收到外部中断的时候调用 S 特权级编写的处理函数 `devintr`，这样无需手动查页表就能访问 S 特权级的数据结构，且 K210 和 qemu 两个平台之间的差别比较小。只需在 k210 平台上引入一个新的 sbi_call 将 `devintr` 入口点传给 M 特权级的 RustSBI 即可。

本次对于内核的更新如下：

1. 终于了解到 CR/LF 是什么了。CR 的 ascii 码是 13，也可以写成 `'\r'`；而 LF 的 ascii 码是 10，也可以写成 `'\n'`。一切都跑通之后，发现在 K210 平台上一个程序跑完之后总是会有一个多余 `>> `，而 Qemu 平台上是没有的。原因在于 Qemu 的内置串口终端换行风格是只有一个 LF，而默认情况下 k210 平台选用的串口终端，也就是 pyserial 提供的 miniterm 换行风格是 CRLF。我们要将 miniterm 的换行风格变成 LF。然后改完发现 fantastic_text 炸了，颜色标记地方变成了乱码...然后去 `kflash.py` 里面扒了一下启动 miniterm 的命令行参数，现在变成这样：

   ```sh
   miniterm --eol LF --dtr 0 --rts 0 --filter direct $(K210-SERIALPORT) 115200
   ```

2. 由于我们实现了在 M 特权级调用 S 特权级声明的外部中断处理函数机制，终于可以在最大程度上统一 k210 和 qemu 平台的中断处理。因此可以移除各平台的 `interrupt` 子模块，全部平台都使用 `interrupt.rs` 中的逻辑进行处理。

   但是如果想完全统一的话，还需要实现一套 CLINT/PLIC 驱动程序，这样比较好看。

   目前的话，我们在 `interrupt.rs` 中加入 k210 外部中断处理函数：

   ```rust
   /// It will be executed in M mode, and it can access kernel address space
   /// after setting mstatus.mprv.
   pub unsafe fn devintr() {
       // on k210, we only allow M mode devintr to be received on
       // hart0-M target after configuring PLIC.
       let hart0m_claim = 0x0C20_0004 as *mut u32;
       let irq = hart0m_claim.read_volatile();
       match irq {
           33 => {
               // UARTHS
               let mut c = (0x3800_0004 as *const u32).read_volatile();
               if c <= 255 {
                   STDIN.push(c as u8);
               }
           }
           _ => {
               panic!("unsupported device interrupt!");
           }
       }
       hart0m_claim.write_volatile(irq);
   }
   ```

   它在 S 特权级的内核里面声明，但是却会在 M 特权级（接收到 M 特权级外部中断之后）调用。我们需要在里面实现完整的 claim/complete 流程。由于它在 S 特权级的内核里面声明，天然可以访问内核里面定义的数据结构而无需手动查页表。

   注意我们出于简单起见，对于 K210 平台，还是始终应该保证只有 hart0 能够接受并处理外部中断。 

   我们需要一个新的 sbi_call 来告知 RustSBI 这个外部中断服务例程入口：

   ```rust
   // sbi.rs
   /// only for K210
   const SBI_REGISTER_DEVINTR: usize = 9;
   
   pub fn register_devintr(entry: usize) {
       sbi_call(SBI_REGISTER_DEVINTR, entry, 0, 0);
   }
   ```

   然后在 k210 平台的设备初始化 `device_init` 中调用这个 sbi_call：

   ```rust
   pub fn device_init(_: PhysicalAddress) {
       ...
       // now, we can receive UARTHS interrupt on hart0!
   
       println!("into sbi::register_devintr!");
       crate::sbi::register_devintr(devintr as usize - 0xffff_ffff_0000_0000);
       crate::drivers::soc::sleep::usleep(50000);
   }
   ```

   注意，我们通过 sbi_call 传递的是服务例程的物理地址。这是因为 RISC-V 提供的 mprv 机制对于取指是不生效的，它依然直接根据物理地址而不通过 MMU。

   然后这样做有一个副作用，就是我们需要在创建地址空间的时候进行整块物理内存的恒等映射，不然会出现访问线程运行栈的 page fault。目前我也不是很了解到底为什么会这样，可能是还不太清楚相对和绝对地址的区别吧。

   总之我们先这样搞，每个线程要浪费额外的 12KiB 进行这些映射：

   ```rust
   // k210/config.rs
   pub const MMIO_INTERVALS: &[(usize, usize)] = &[
       (0x0200_0000, 0x1000),      /* CLINT     */
       // we only need claim/complete for target0 after initializing
       (0x0C20_0000, 0x1000),      /* PLIC      */
       ...
       (0x8000_0000, 0x600000),    /* Memory    */
   ];
   ```

   此次还发现了之前对于 PLIC MMIO 范围的设置错误 bug。事实上 SiFive 对于 PLIC 的 MMIO 设置很宽，从 0x0c00_0000 直到 0x1000_0000 都是它的范围。但是在运行时，也就是初始化之后我们只会用到 target 0（也就是 hart0m）的 claim/complete，所以只映射这个就行了。

   在重构的实现中，我们考虑支持大页映射，这样可以大幅减少所需的内存。一种听上去不错的做法：弄一个闭包，在调用 devintr 前后映射和解映射这些页应该是行不通的，可能在跳转过去之前就炸了。

3. RustSBI 中的改动

   首先是在 ecall from S 的时候特判是不是 `SBI_REGISTER_DEVINTR` 调用：

   ```rust
   Trap::Exception(Exception::SupervisorEnvCall) => {
       if trap_frame.a7 == 0x09 {
           // 如果是的话，我们将 IRQ 的物理地址保存到一个 static mut 里面
           // 这里可能会有些安全问题？
           unsafe { DEVINTRENTRY = trap_frame.a0; }
       } else {
           let params = [trap_frame.a0, trap_frame.a1, trap_frame.a2, trap_frame.a3];
           let ans = rustsbi::ecall(trap_frame.a7, trap_frame.a6, params);
           trap_frame.a0 = ans.error;
           trap_frame.a1 = ans.value;
       }
       mepc::write(mepc::read().wrapping_add(4));
   }
   ```

   然后是修改 M 特权级外部中断的处理逻辑：

   ```rust
   Trap::Interrupt(Interrupt::MachineExternal) => {
       /* remove legacy software delegation */
       unsafe {
           let mut mstatus: usize;
           llvm_asm!("csrr $0, mstatus" : "=r"(mstatus) ::: "volatile");
           // set mstatus.mprv
           mstatus |= 1 << 17;
           // it may trap from U/S Mode
           // save mpp and set mstatus.mpp to S Mode
           let mpp = (mstatus >> 11) & 3;
           mstatus = mstatus & !(3 << 11);
           mstatus |= 1 << 11;
           // drop mstatus.mprv protection
           llvm_asm!("csrw mstatus, $0" :: "r"(mstatus) :: "volatile");
           fn devintr() {
               unsafe {
                   // call devintr defined in application
                   // we have to ask compiler save ra explicitly
                   llvm_asm!("jalr 0($0)" :: "r"(DEVINTRENTRY) : "ra" : "volatile");
               }
           }
           // compiler helps us save/restore caller-saved registers,
           // and devintr which is defined in application helps us
           // save/restore callee-saved registers
           devintr();
           // restore mstatus
           mstatus |= mpp << 11;
           mstatus -= 1 << 17;
           llvm_asm!("csrw mstatus, $0" :: "r"(mstatus) :: "volatile");
       }
   }
   ```

   该 ecall 在使用的时候要注意：

   * 传进来的必须是服务例程的物理地址；
   * 进入中断之前所在的页表必须支持能以 S 特权级以恒等的虚实映射访问整块物理内存。

