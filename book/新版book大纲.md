# 新版 book 大纲

## 代码与文档风格



## 知识点总览

### RISC-V 架构篇

* RISC-V 指令集，包括通用寄存器以及一些常见的功能寄存器（如 sp, ra）等，了解常见的 RISC-V 汇编指令，如算术、访存、跳转指令
* RISC-V 调用规范：明确调用规范存在的意义和为何需要一个栈，了解 caller/callee saved 寄存器各有哪些，如何传递参数和返回值，以及 stackframe 的分布
* RISC-V 特权级与 trap 处理：最基本的情况下只需了解

### Rust 编程语言篇

### 操作系统篇

## lab0: 最小化内核

代码内容一直到最小化内核，并支持格式化输出。最后可以在模拟器/k210 串口终端里面看到 Hello world。

涉及内容：移除 OS 支持启用 no_std，Rust 模块化编程结构，链接脚本（与编译相关，涉及到程序的内存布局），初始化 `entry.asm`（这里面就已经要强调栈的作用了），RustSBI 与调用 SBI 接口，借用 SBI 接口来实现格式化输出。

## 附录 A：RISC-V 架构相关内容

## Log

新的内存布局：用户和内核共处同一个地址空间。整块物理内存（包括内核的代码/数据）全部以 $\mathtt{0xFFFF\_FFFF\_0000\_0000}$ 的偏移量移动到高地址空间，所有 MMIO （都低于 $\mathtt{0x8000\_0000}$）全部恒等映射到低地址空间，这个是为了兼容 M 态驱动程序。随后，要求所有的用户程序都从 $\mathtt{0x8000\_0000}$ 作为起始地址。这样就能够保证虚拟地址空间不产生冲突了。且尽可能和原来的实现兼容。

移除线程 Thread 强调进程 Process。注意现在的进程 Process 里面表示一个（单线程）用户程序

之前实现的不好的 syscall，比如 fork, exit, exec。完全没有的 syscall，比如 sbrk（lazy allocation）以及 fork（COW）。但是目前 Tutorial 的实现是一个 Process 里面有多个 Thread，每个 Thread 里面有一个 `Range<VirtualAddress>` 表示其运行栈在进程地址空间中的位置区间。在有多个 Thread 的情况下，fork 有点不太好弄...或者定义为只能对只有一个 Thread 的 Process 调用 fork？但目前来说完全没有必要做多 Thread 的 Process。目前多 Thread 的 Process 仅用在内核线程里面。

主要是 xv6 里面的测试程序挺爽的...

1. 没有站在 syscall 角度考虑问题，比如 xv6 的第一个 lab，确定 syscall 语义
2. 补充 syscall，如 ipc 的 pipe
3. 展开文件系统
4. 展开 Mutex

## 下一步计划

1. 不在代码中体现线程的概念，只保留进程 Process 同时作为资源控制和 CPU 调度单位

   资源控制：地址空间（复用 MemorySet），打开的文件描述符表

   CPU 调度单位：需要保存进程的运行状态、进程的 PID、进程在内核被切换出去之后的上下文（可以被看成一个函数调用，中断上下文在栈上无需保存）、内核栈在进程地址空间中的位置

2. 进程地址空间分布：不对内核和用户地址空间进行隔离

   低于 0x80000000：设备 MMIO 的恒等映射

   从 0x80000000 开始：用户程序的代码、数据（从 ELF 中解析），接下来属于用户堆区域，可以通过 `sbrk` 系列系统调用来增长或缩减用户堆的大小

   从 0xFFFFFFFF80000000 向下：首先是一个带有 guard page 的进程专属的内核栈，然后是一个带有 guard page 的进程专属的用户栈（需要以某种方式传递 `int argc, char* argv[]` 参数）

   从 0xFFFFFFFF80000000 向上：整块物理内存偏移量为 0xFFFFFFFF00000000 的线性映射，包括 RustSBI 代码、数据段，内核代码、数据（内含启动栈和内核堆），还有剩余可用的物理内存

3. 取消内核线程，将其变为内核进程，在 Process 加一个域表示是否为内核进程，这样易于实现。实现的时候要注意内核进程就无须开一个用户栈了，在 trap 的时候也无需换栈。

4. 子进程与进程回收

   除了 Runnable/Running/Sleeping 之外，进程还有一个 Exit 状态，表示它调用 exit 系统调用退出或者是由于某种原因被内核杀死。但是一个进程不能在最后一次进入内核态的时候自己把自己的资源全部回收，主要是因为目前代码还是在它自己的内核栈上面跑的。因此先将其用户代码、数据段包括用户栈回收，然后将其标志为 Exit 状态，并在 PCB 里面保存退出状态。其父进程可以通过 wait 系统调用来获取一个 Exit 的子进程的退出状态，顺带回收它的内核栈和 PCB。

   当一个进程退出时，将它的所有子进程让渡给初始进程 initproc，这个进程的任务就是回收之前还没有回收的进程。同时还需要考虑它的父进程，如果它的父进程正处于 wait 子进程退出的状态，则唤醒父进程。因此应该有一个全局的 condvar 来保存所有处于此状态的进程。

   xv6 风格由于没有内核堆分配器，因此大多数数据结构的风格都是开一个定长数组，对于内存有一定程度上的浪费。目前 tutorial 无需做到像是 biscuit 那样对于堆内存有着相对容错且稳定的设计，如果堆内存不足，内核直接 panic 即可。

5. Unix 万物皆文件

   即 xv6 里面的 file，这里继承的是 Unix 的万物皆文件哲学，也即每种资源都可以用一个文件描述符来访问，支持 open/close/read/write 等操作。

   目前我们预计提供三种不同的资源：首先是文件系统，代表块设备；其次是串口输入输出，代表字符设备；最后是作为 IPC 的管道，作为某种内核资源。

6. 高优先级系统调用

   * `int fork()`：fork 出一个子进程，对于父进程返回子进程的 PID，对于子进程返回 0。如果物理页帧不足，则不 fork 子进程并返回 -1。

   * `int exit(int status)`：调用 exit 退出进程，该函数不应该返回。传入的 `status` 将作为进程的返回状态，可以被父进程捕获到。

   * `int wait(int* status)`：等待**一个**子进程退出并将其返回状态存储在 `status` 里面，其返回值为子进程的 PID。如果该进程没有任何子进程则立即返回 -1，此时应忽略 `status` 里面的值。

   * `int getpid()`：返回当前进程的 PID。

   * `int exec(char* file, char* argv[])`：用 `file` 处的用户程序替换掉进程地址空间中的用户代码、数据段，清空用户栈并在上面传入 `argv` 作为可以被捕获到的初始参数。可能会消耗更多物理页面，因此如果物理页面不足，应放弃替换并返回 -1；否则不应该返回而是从用户程序的入口点开始执行。

   * `int open(char* file, int flags)`：以 `flags` 标志打开位于 `file` 处的 Unix 资源。暂时只支持打开位于块设备文件系统上的文件或目录，而不支持打开 `/dev/tty` 等其他设备。如果成功，返回其 fd；否则返回 -1。

     `int close(int fd)`：释放当前进程的 Unix 资源 `fd`。如果成功返回 0，如果失败（如当前进程不存在资源 `fd`）则应该返回 -1。

   * `int write(int fd, char* buf, int n)`：尝试向 Unix 资源 `fd` 内写入 `buf` 开头的 `n` 字节 ，返回实际写入的字节数。

     `int read(int fd, char* buf, int n)`：尝试从 Unix 资源 `fd` 读 `n` 字节到 `buf` 开头的一块内存，返回实际读到的字节数。

     注意 `write/read` 的表现随着 `fd` 对应的资源类型（文件系统中的文件/目录 `T_INODE`、串口设备 `T_DEVICE`、管道 `T_PIPE`）不同会发生变化，这里暂且不考虑。

   * `int pipe(int p[])`：创建一个管道，返回的两个 fd `p[0], p[1]` 分别表示管道的读端和写端。返回 0。

7. 低优先级系统调用

   * `int kill(int pid)`：杀死一个 PID 为 `pid` 的进程。如果成功则返回 0，否则返回 -1。（注意应该不允许杀死自己）
   * `int sleep(int n)`：休眠一个进程，时长为 `n` 个 ticks（在调度模型中进程执行 1 个 tick 时候就会切换到其他进程），返回值为 0。
   * `char* sbrk(int n)`：增长用户堆内存 `n` 字节，`n` 有可能为负数。 返回这块内存的起始地址，如果物理页面不足则返回 -1 也就是 0xFFFFFFFFFFFFFFFF。（在 libc 内可以将 `sbrk` 包装成 `malloc` 和 `free`，但是在 Rust 里面还是倾向于事先在数据段分配一块用户堆内存用于动态分配 ）
   * 创建/删除文件/目录，获取元数据之类的系统调用。

8. 参考 xv6 或者 ucore 实现一个简单的文件系统

   最先只需考虑依次实现：磁盘驱动（qemu 平台的 virtio 以及 k210 平台的 sd 卡）的封装、磁盘布局的实现（超级块、inode 和数据块区域及其 bitmap）、将 inode 包装为 Unix 资源类型 file 并实现相应 syscall

   时间充裕的话可以考虑实现块缓存或者日志系统

9. 手动实现 `spin::Mutex` 并解释其原理

   只需利用 Rust core::sync::atomic 提供的原子类型 `AtomicBool` 或者参照 xv6 直接用 RISC-V 提供的原子 CAS 系列指令即可。需要说明的是原子指令不仅仅是一条指令进行多个操作，站在多核角度还需要考虑内存一致性模型，以及 Memory Ordering。比如 RISC-V 提供的 LR-SC 指令和普通的 Load/Store 指令一样只有读或者写一个操作，只是设置了 Memory Ordering 之后也能用来实现 spinlock。这部分可以稍微介绍一下，但目前我也不是很懂。

   内核中基本上所有的共享资源都需要受到 spinlock 的保护。

   之后除了已有的 `CondVar` 之外，还可以在代码或者练习中实现其他同步原语，并在内核中进行测试。

10. 搬运 xv6 中所有能用的测试程序和测试脚本，也可以考虑从 ucore 里面移植一些。

