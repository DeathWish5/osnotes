# Tock

# 论文阅读

## 1 Introduction

通用计算平台的硬件特征：特权级（阻止直接访问硬件）、MMU（虚拟地址空间，隔离）、较大的 RAM（可以动态分配内核数据结构，更有效利用内存）。然而在嵌入式平台成本和功耗受限，只能实现上述的部分特征：更简单的特权级、简化版的内存保护 MPU、以及很小（甚至只有 64KiB ）的 RAM。于是虽然**内存隔离**和**动态内存管理**在软件工程和性能（？）的角度更好，在嵌入式平台上也只能使用比较简单的编程模型。

比如：嵌入式平台上经常把应用和内核合成为一个单独的程序。优点：更容易共享数据，系统调用变为开销更小的函数调用。但是也有缺点：难以支持多任务。而且缺少了内存隔离难以保证整个系统的稳定性和应用的安全性。

嵌入式平台为了**长时运行**和**避免错误**经常使用静态内存分配。优点：避免了堆内存耗尽，尤其是在内存紧缺的情况极大提升了稳定性。缺点：需要预留最大并发情况下的内存，内存利用效率较低。而且为每种资源预留多少内存不好估计，还会随着具体应用的特征而发生变化。

而 Tock 的目标是在**嵌入式平台上更好支持多任务**，优点如下：

* 提供错误隔离和内核数据结构的动态分配。
* 使用类型安全的 Rust 编写，绝大部分代码通过编译器的检验。
* 为很多实际硬件提供了进程抽象。
* 为了避免内存利用效率和并发之间的 trade-off，使用了 **grant**。暂时看不懂这是个什么东西，后面再看。

## 2 Background & Motivation

曾经的嵌入式程序用途单一，应用本身决定一整套硬件、OS 配置和软件编写。但现在出现了新型的嵌入式软件平台支持多个独立且可以动态加载的应用。（比如说鸿蒙？大概就是需要有灵活可配置、相互隔离以保证安全的多个组件。）

### 2.1 Microcontrollers

MCU 资源受限：频率数十MHz/RAM数十KiB/1MiB甚至更少的闪存。受限于功耗，摩尔定律并不会突破这些资源限制。文中给出了相隔 13 年的两款 MCU 的配置参数，可以发现变化不大，比如 RAM 只是从 10KiB 增长到 64KiB。

32 位 Cortex-M CPU 提供了早期 MCU 没有提供的 MPU 内存管理，它既不是分页（虚拟地址）也不是分段（线性地址），直接访问物理地址，但是会在应用/应用和应用/内核之间提供内存保护。但是在 OS 中使用 MPU 进行内存保护好处有限。比如在 FreeRTOS 中使用 MPU 禁止应用写入内核的内存区域。但是 FreeRTOS 的 syscall 需要内核**信任应用传过来的任何指针**（糟糕的安全性），这样应用还是能通过 syscall 读写内存的任意位置。

### 2.2 Embedded Operating Systems

嵌入式操作系统主要需要提供五种关键特性：并发、资源耗尽的可靠性、错误隔离、内存有效利用、运行时应用更新。

**可靠性**：嵌入式应用非常注意稳定性，即使以性能、吞吐量、手动维护性为代价。比如 RAM 就经常静态分配或是只允许在启动的时候动态分配。

**并发**：嵌入式平台受功耗限制，经常需要提高并发，让很多操作在同一时间进行，因为 I/O 的时候处理器就可以低频休眠，更加**省电**。Ti nyOS 和 SOS 使用协作调度简化了栈管理（类似协程）。但是这样也有 CPU 资源饥饿的风险，所以 TOSThreads/FreeRTOS/RIOTOS 都有采用抢占式调度。

**效率**：特指更有效利用珍贵的 RAM 资源。无论是静态分配（TinyOS/Arduino）或是动态分配（SOS/TOSThreads）都需要考虑到这一点。

**错误隔离**：在各组件之间隔离错误是支持多任务的基础。但是直到最近嵌入式硬件的保护机制（如内存保护）都很不完善，因此只能依靠小心的 API 设计或者是功能受限的 MPU。甚至一些已有系统将应用运行在类似 JVM 的字节码解释器上来通过软件的方式进行错误隔离。

强大的 Tock 基于新的硬件特性和编程语言支持实现了所有特性！